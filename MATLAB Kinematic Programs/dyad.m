function [values] = dyad(r1,r2,xA,yA,xdA,ydA,xddA,yddA,xB,yB, ...                     xdB,ydB,xddB,yddB,sigma,flag,negflag)% This function analyzes a dyad (ABC) when the position, velocity, and % acceleration of A and B are given, and the position, velocity and % acceleration of C is to be found.  The input values are:%r1      = length of first link%r2      = length of second link%xA      = x coordinate of point A%yA      = y coordinate of point A%xdA     = x coordinate of velocity of point A%ydA     = y coordinate of velocity of point A%xddA    = x coordinate of aceleration of point A%yddA    = y coordinate of aceleration of point A%sigma   = +1 or -1.  Identifies assembly mode%negflag = 0 if negative angles are to be converted to positive angles by %          adding 360 degrees to the angle if it is negative. %negflag = 1 if negative angles are not to be converted to positive angles. %flag    = analysis flag.  If flag = 1, only a position analysis is conducted. %          If flag = 2, both a position and velocity analysis is conducted. %		     If flag = 3, a position, velocity, and acceleration analysis%		               is conducted.% The results are returned in the vector "values".  The answers are % stored in values according to the following:%values (1:2)   = x,y coordinates of point C%values (3:4)   = angular position of links 3 and 4 (deg)%values (5:6)   = x,y coordinates of velocity of point C%values (7:8)   = angular velocity of links 3 and 4 (rad/sec)%values (9:10)  = x,y coordinates of acceleration of point C%values (11:12) = angular acceleration of links 3 and 4 (rad/sec^2)%values (13)    = assembly flag.  If values(13) = 0, mechanism cannot %                 assembled.%convert input datavalues=zeros(13,1);theta=zeros(2,1);td=zeros(2,1);tdd=zeros(2,1);fact=pi/180;% position calculationsA=2*r2*(xB-xA);B=2*r2*(yB-yA);C=(xB-xA)^2+(yB-yA)^2-r1^2+r2^2;arg=B*B-C*C+A*A;if (arg>=0)	values(13)=1;% Check for the denominator equal to zero	if abs(C-A)>=(10^(-10)*(abs(C)+abs(A)))		t2=2*atan((-B+sigma*sqrt(arg))/(C-A));		s2=sin(t2);		c2=cos(t2);		t1=atan2(((yB-yA)+r2*s2),((xB-xA)+r2*c2));		s1=sin(t1);		c1=cos(t1);	elseif abs(C-A)<(10^(-10)*(abs(C)+abs(A)))	% If the denominator is zero, compute theta1 first		A=2*r1*(xA-xB);		B=2*r1*(yA-yB);		C=(xA-xB)^2+(yA-yB)^2-r2^2+r1^2;		arg=B*B-C*C+A*A;		if (arg>=0)			t1=2*atan((-B-sigma*sqrt(arg))/(C-A));			s1=sin(t1);			c1=cos(t1);			t2=atan2(((yA-yB)+r1*s1),((xA-xB)+r1*c1));			s2=sin(t2);			c2=cos(t2);		end		end	if t1 < 0 && negflag==0; t1=t1+2*pi; end	if t2 < 0 && negflag==0; t2=t2+2*pi; end	theta1=t1/fact;	theta2=t2/fact;	% coordinates of C		values(1)=xA+r1*c1;	values(2)=yA+r1*s1;	values(3)=theta1;	values(4)=theta2;%velocity calculation	if flag>1		AM=[r1*s1, -r2*s2; -r1*c1, r2*c2];		BM=[xdA-xdB;ydA-ydB];		CM=AM\BM;		td1=CM(1);		td2=CM(2);	% velocity of C			values(5)=xdA-r1*s1*td1;		values(6)=ydA+r1*c1*td1;		values(7)=CM(1);		values(8)=CM(2);	end	%acceleration calculation		if flag >2		BM=[xddA-xddB-r1*td1^2*c1+r2*td2^2*c2;yddA-yddB-r1*td1^2*s1+r2*td2^2*s2];		CM=AM\BM;		tdd1=CM(1);		% accelerations of C			values(9)=xddA-r1*td1^2*c1-r1*tdd1*s1;		values(10)=yddA-r1*td1^2*s1+r1*tdd1*c1;		values(11)=CM(1);		values(12)=CM(2);	endend