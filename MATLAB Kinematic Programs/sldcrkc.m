function [values] = sldcrkc(r2,r3,r4,theta2,td2,tdd2,sigma,theta1,flag)% This function analyzes a slider crank mechanism when the crank% is the driving link.  The input values are:%r2      = length of vector 2 (crank)%r3      = length of vector 3 (coupler)%r4      = length of vector 4 (slider offset)%theta2  = crank angle (degrees)%td2     = crank angular velocity (rad/sec)%tdd2    = crank angular acceleration (rad/sec^2)%sigma   = +1 or -1.  Identifies assembly mode%theta1 = angle between slider velocity and frame x axis (degrees).%flag    = analysis flag.  If flag = 1, only a position analysis is conducted. %          If flag = 2, both a position and velocity analysis is conducted. %		   If flag = 3, a position, velocity, and acceleration analysis%		               is conducted.% The results are returned in the vector "values".  The answers are % stored in values according to the following:%values (1:4)   = vector lengths%values (5:8)   = vector angles (degrees)%values (9:12)  = derivatives of vector lengths%values (13:16) = derivatives of vector angles (rad/sec)%values (17:20) = second derivatives of vector lengths%values (21:24) = second derivatives of vector angles (rad/sec^2)%values (25:26) = x,y components of position of crank pin (point Q)%values (27:28) = x,y components of position of piston pin (point P)%values (29:30) = x,y components of velocity of crank pin (point Q)%values (31:32) = x,y components of velocity of piston pin (point P)%values (33:34) = x,y components of acceleration of crank pin (point Q)%values (35:36) = x,y components of acceleration of piston pin (point P)%values (37)    = assembly flag.  If values(37) = 0, mechanism cannot %                 assembled.%convert input datavalues=zeros(37,1);r(2)=r2;r(3)=r3;r(4)=r4;theta(1)=theta1;theta(2)=theta2;theta(4)=theta1+90;fact=pi/180;t1=theta(1)*fact;t2=theta(2)*fact;t4=theta(4)*fact;td=zeros(4,1);tdd=zeros(4,1);rd=zeros(4,1);rdd=zeros(4,1);td(1)=0;td(2)=td2;tdd(2)=tdd2;s2=sin(t2);c2=cos(t2);s1=sin(t1);c1=cos(t1);s4=sin(t4);c4=cos(t4);% position calculationsA=2*r(4)*(c1*c4+s1*s4)-2*r(2)*(c1*c2+s1*s2);B=r(2)*r(2)+r(4)*r(4)-r(3)*r(3)-2*r(2)*r(4)*(c2*c4+s2*s4);arg=A*A-4*B;if (arg>=0)	values(37)=1; %assembly flag	r(1)=(-A+sigma*sqrt(arg))/2;	t3=atan2((r(1)*s1+r(4)*s4-r(2)*s2),(r(1)*c1+r(4)*c4-r(2)*c2));	theta(3)=t3/fact;	s3=sin(t3);	c3=cos(t3);		% coordinates of P and Q		values(25)=r(2)*c2;	values(26)=r(2)*s2;	values(27)=values(25)+r(3)*c3;	values(28)=values(26)+r(3)*s3;	%velocity calculation	if flag>1		AM=[c1, r(3)*s3; s1, -r(3)*c3];		BM=[-r(2)*td(2)*s2;r(2)*td(2)*c2];		CM=AM\BM;		rd(1)=CM(1);		td(3)=CM(2);			% velocities of P and Q			values(29)=-r(2)*td(2)*s2;		values(30)=r(2)*td(2)*c2;		values(31)=values(29)-r(3)*td(3)*s3;		values(32)=values(30)+r(3)*td(3)*c3;	end		%acceleration calculation		if flag>2		BM=[-r(2)*tdd(2)*s2-r(2)*td(2)*td(2)*c2-r(3)*td(3)*td(3)*c3;...    		r(2)*tdd(2)*c2-r(2)*td(2)*td(2)*s2-r(3)*td(3)*td(3)*s3];		CM=AM\BM;		rdd(1)=CM(1);		tdd(3)=CM(2);				% accelerations of P and Q			values(33)=-r(2)*tdd(2)*s2-r(2)*td(2)*td(2)*c2;		values(34)=r(2)*tdd(2)*c2-r(2)*td(2)*td(2)*s2;		values(35)=values(33)-r(3)*tdd(3)*s3-r(3)*td(3)*td(3)*c3;		values(36)=values(34)+r(3)*tdd(3)*c3-r(3)*td(3)*td(3)*s3;	endend%store results in array valuesfor i = 1:4	values(i)=r(i);	values(i+4)=theta(i);	values(i+8)=rd(i);	values(i+12)=td(i);	values(i+16)=rdd(i);	values(i+20)=tdd(i);end