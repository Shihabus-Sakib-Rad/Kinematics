function [values] = sldcrks(r1,r2,r3,r4,rd1,rdd1,sigma,theta1,flag)% This function analyzes a slider crank mechanism when the slider% is the driving link.  The input values are:%r1      = length of vector 1%r2      = length of vector 2 (crank)%r3      = length of vector 3 (coupler)%r4      = length of vector 4 (slider offset)%rd1     = slider velocity%rdd1    = slider acceleration%sigma   = +1 or -1.  Identifies assembly mode%theta1  = angle between slider velocity and frame x axis (Degrees).%flag    = analysis flag.  If flag = 1, only a position analysis is conducted. %          If flag = 2, both a position and velocity analysis is conducted. %		     If flag = 3, a position, velocity, and acceleration analysis%		               is conducted.% The results are returned in the vector "values".  The answers are % stored in values according to the following:%values (1:4)   = vector lengths%values (5:8)   = vector angles (degrees)%values (9:12)  = derivatives of vector lengths%values (13:16) = derivatives of vector angles (rad/sec)%values (17:20) = second derivatives of vector lengths%values (21:24) = second derivatives of vector angles (rad/sec^2)%values (25:26) = x,y components of position of crank pin (point Q)%values (27:28) = x,y components of position of piston pin (point P)%values (29:30) = x,y components of velocity of crank pin (point Q)%values (31:32) = x,y components of velocity of piston pin (point P)%values (33:34) = x,y components of acceleration of crank pin (point Q)%values (35:36) = x,y components of acceleration of piston pin (point P)%values (37)    = assembly flag.  If values(37) = 0, mechanism cannot %                 assembled.%convert input datavalues=zeros(37,1);r(1)=r1;r(2)=r2;r(3)=r3;r(4)=r4;theta(1)=theta1;theta(4)=theta1+90;fact=pi/180;t1=theta(1)*fact;t4=theta(4)*fact;td=zeros(4,1);tdd=zeros(4,1);rd=zeros(4,1);rdd=zeros(4,1);td(1)=0;tdd(1)=0;rd(1)=rd1;rdd(1)=rdd1;s1=sin(t1);c1=cos(t1);s4=sin(t4);c4=cos(t4);% position calculationsA=-2*r(1)*r(2)*c1-2*r(2)*r(4)*c4;B=-2*r(1)*r(2)*s1-2*r(2)*r(4)*s4;C=r(1)*r(1)+r(2)*r(2)+r(4)*r(4)-r(3)*r(3)+2*r(1)*r(4)*(c1*c4+s1*s4);arg=B*B-C*C+A*A;if (arg>=0)	values(37)=1; %assembly flag	t2=2*atan((-B+sigma*sqrt(arg))/(C-A));	s2=sin(t2);	c2=cos(t2);	t3=atan2((r(1)*s1+r(4)*s4-r(2)*s2),(r(1)*c1+r(4)*c4-r(2)*c2));	theta(2)=t2/fact;	theta(3)=t3/fact;	s3=sin(t3);	c3=cos(t3);		% coordinates of P and Q		values(25)=r(2)*c2;	values(26)=r(2)*s2;	values(27)=values(25)+r(3)*c3;	values(28)=values(26)+r(3)*s3;	%velocity calculation	if flag>1		AM=[-r(2)*s2, -r(3)*s3; r(2)*c2, r(3)*c3];		BM=[rd(1)*c1;rd(1)*s1];		CM=AM\BM;		td(2)=CM(1);		td(3)=CM(2);			% velocities of P and Q			values(29)=-r(2)*td(2)*s2;		values(30)=r(2)*td(2)*c2;		values(31)=values(29)-r(3)*td(3)*s3;		values(32)=values(30)+r(3)*td(3)*c3;	end	%acceleration calculation		if flag>2		BM=[r(2)*td(2)*td(2)*c2+r(3)*td(3)*td(3)*c3+rdd(1)*c1;...    		r(2)*td(2)*td(2)*s2+r(3)*td(3)*td(3)*s3+rdd(1)*s1];		CM=AM\BM;		tdd(2)=CM(1);		tdd(3)=CM(2);			% accelerations of P and Q			values(33)=-r(2)*tdd(2)*s2-r(2)*td(2)*td(2)*c2;		values(34)=r(2)*tdd(2)*c2-r(2)*td(2)*td(2)*s2;		values(35)=values(33)-r(3)*tdd(3)*s3-r(3)*td(3)*td(3)*c3;		values(36)=values(34)+r(3)*tdd(3)*c3-r(3)*td(3)*td(3)*s3;	endend%store results in array valuesfor i = 1:4	values(i)=r(i);	values(i+4)=theta(i);	values(i+8)=rd(i);	values(i+12)=td(i);	values(i+16)=rdd(i);	values(i+20)=tdd(i);end