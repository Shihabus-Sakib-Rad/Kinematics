function [values] = sldcrkco(r2,r3,r4,theta3,td3,tdd3,sigma,theta1,flag)% This function analyzes a slider crank mechanism when the coupler% is the driving link.  The input values are:%r2      = length of vector 2 (crank)%r3      = length of vector 3 (coupler)%r4      = length of vector 4 (slider offset)%theta3  = coupler angle (degrees)%td3     = coupler angular velocity (rad/sec)%tdd3    = coupler angular acceleration (rad/sec^2)%sigma   = +1 or -1.  Identifies assembly mode%theta1 = angle between slider velocity and frame x axis (degrees).%flag    = analysis flag.  If flag = 1, only a position analysis is conducted. %          If flag = 2, both a position and velocity analysis is conducted. %		   If flag = 3, a position, velocity, and acceleration analysis%		               is conducted.% The results are returned in the vector "values".  The answers are % stored in values according to the following:%values (1:4)   = vector lengths%values (5:8)   = vector angles (degrees)%values (9:12)  = derivatives of vector lengths%values (13:16) = derivatives of vector angles (rad/sec)%values (17:20) = second derivatives of vector lengths%values (21:24) = second derivatives of vector angles (rad/sec^2)%values (25:26) = x,y components of position of crank pin (point Q)%values (27:28) = x,y components of position of piston pin (point P)%values (29:30) = x,y components of velocity of crank pin (point Q)%values (31:32) = x,y components of velocity of piston pin (point P)%values (33:34) = x,y components of acceleration of crank pin (point Q)%values (35:36) = x,y components of acceleration of piston pin (point P)%values (37)    = assembly flag.  If values(37) = 0, mechanism cannot %                 assembled.%convert input datavalues=zeros(37,1);r(2)=r2;r(3)=r3;r(4)=r4;theta(1)=theta1;theta(3)=theta3;theta(4)=theta1+90;fact=pi/180;t1=theta(1)*fact;t3=theta(3)*fact;t4=theta(4)*fact;td=zeros(4,1);tdd=zeros(4,1);rd=zeros(4,1);rdd=zeros(4,1);td(1)=0;td(3)=td3;tdd(3)=tdd3;s3=sin(t3);c3=cos(t3);s1=sin(t1);c1=cos(t1);s4=sin(t4);c4=cos(t4);% position calculationsA=2*r(4)*(c1*c4+s1*s4)-2*r(3)*(c1*c3+s1*s3);B=r(3)^2+r(4)^2-r(2)^2-2*r(3)*r(4)*(c3*c4+s3*s4);arg=A*A-4*B;if (arg>=0)	values(37)=1; %assembly flag	r(1)=(-A+sigma*sqrt(arg))/2;	t2=atan2((r(1)*s1+r(4)*s4-r(3)*s3),(r(1)*c1+r(4)*c4-r(3)*c3));	theta(2)=t2/fact;	s2=sin(t2);	c2=cos(t2);		% coordinates of P and Q		values(25)=r(2)*c2;	values(26)=r(2)*s2;	values(27)=values(25)+r(3)*c3;	values(28)=values(26)+r(3)*s3;%velocity calculation	if flag>1		AM=[c1, r(2)*s2; s1, -r(2)*c2];		BM=[-r(3)*td(3)*s3;r(3)*td(3)*c3];		CM=AM\BM;		rd(1)=CM(1);		td(2)=CM(2);			% velocities of P and Q			values(29)=-r(2)*td(2)*s2;		values(30)=r(2)*td(2)*c2;		values(31)=values(29)-r(3)*td(3)*s3;		values(32)=values(30)+r(3)*td(3)*c3;	end		%acceleration calculation		if flag>2		BM=[-r(3)*tdd(3)*s3-r(3)*td(3)*td(3)*c3-r(2)*td(2)*td(2)*c2;...    		r(3)*tdd(3)*c3-r(3)*td(3)*td(3)*s3-r(2)*td(2)*td(2)*s2];		CM=AM\BM;		rdd(1)=CM(1);		tdd(2)=CM(2);				% accelerations of P and Q			values(33)=-r(2)*tdd(2)*s2-r(2)*td(2)*td(2)*c2;		values(34)=r(2)*tdd(2)*c2-r(2)*td(2)*td(2)*s2;		values(35)=values(33)-r(3)*tdd(3)*s3-r(3)*td(3)*td(3)*c3;		values(36)=values(34)+r(3)*tdd(3)*c3-r(3)*td(3)*td(3)*s3;	endend%store results in array valuesfor i = 1:4	values(i)=r(i);	values(i+4)=theta(i);	values(i+8)=rd(i);	values(i+12)=td(i);	values(i+16)=rdd(i);	values(i+20)=tdd(i);end