function [values] = fourbar_co(r1,r2,r3,r4,rc,beta,theta3,td3,tdd3,sigma,theta1,flag)% This function analyzes a four-bar linkage when the coupler is the % driving link.  The input values are:%r1      = length of vector 1 (frame)%r2      = length of vector 2 (crank)%r3      = length of vector 3 (coupler)%r4      = length of vector 4 (slider offset)%rc      = length of the coupler2%beta    = the angle between the coupler and the coupler2%theta3  = coupler angle (degrees)%sigma   = +1 or -1.  Identifies assembly mode% The results are returned in the vector "values".  The answers are % stored in values according to the following:% the first bushing position is in the origin (0,0)%values (1:4)   = vector lengths%values (5:8)   = vector angles (degrees)%values (9:12)  = derivatives of vector angles (rad/sec)%values (13:16) = second derivatives of vector angles (rad/sec^2)%values (17:18) = x,y components of position of crank pin (point Q)%values (19:20) = x,y components of position of follower pin (point P)%values (21:22) = x,y components of velocity of crank pin (point Q)%values (23:24) = x,y components of velocity of follower pin (point P)%values (25:26) = x,y components of acceleration of crank pin (point Q)%values (27:28) = x,y components of acceleration of follower pin (point P)%values (29)    = assembly flag.  If values(29) = 0, mechanism cannot assembled.%convert input datavalues=zeros(29,1);r(1)=r1;r(2)=r2;r(3)=r3;r(4)=r4;theta=zeros(4,1);td=zeros(4,1);tdd=zeros(4,1);theta(1)=theta1;theta(3)=theta3;fact=pi/180;t1=theta(1)*fact;t3=theta(3)*fact;s1=sin(t1);c1=cos(t1);s3=sin(t3);c3=cos(t3);% position calculationsA=2*r1*r4*c1-2*r3*r4*c3;B=2*r1*r4*s1-2*r3*r4*s3;C=r1*r1+r3*r3+r4*r4-r2*r2-2*r1*r3*(c1*c3+s1*s3);arg=B*B-C*C+A*A;if (arg>=0)	values(29)=1;        % Check for the denominator equal to zero    if abs(C-A)>=(10^(-10)*(abs(C)+abs(A)))		t4=2*atan((-B+sigma*sqrt(arg))/(C-A));		s4=sin(t4);		c4=cos(t4);		t2=atan2((r1*s1+r4*s4-r3*s3),(r1*c1+r4*c4-r3*c3));		s2=sin(t2);		c2=cos(t2);    elseif abs(C-A)<(10^(-10)*(abs(C)+abs(A)))        % If the denominator is zero, compute theta(2) first		A=-2*r1*r2*c1+2*r3*r2*c3;		B=-2*r1*r2*s1+2*r3*r2*s3;		C=r1*r1+r3*r3+r2*r2-r4*r4-2*r1*r3*(c1*c3+s1*s3);		arg=B*B-C*C+A*A;        if (arg>=0)			t2=2*atan((-B-sigma*sqrt(arg))/(C-A));			s2=sin(t2);			c2=cos(t2);			t4=atan2((-r1*s1+r2*s2+r3*s3),(-r1*c1+r2*c2+r3*c3));			s4=sin(t4);			c4=cos(t4);        end	    end	theta(4)=t4/fact;	theta(2)=t2/fact;		% coordinates of P and Q	values(17)=r2*c2;	values(18)=r2*s2;	values(19)=values(17)+r3*c3;    values(20)=values(18)+r3*s3;        %velocity calculation    if flag>1		td(3)=td3;		AM=[-r2*s2, r4*s4;-r2*c2, r4*c4];		BM=[r3*td(3)*s3;r3*td(3)*c3];		CM=AM\BM;		td(2)=CM(1);		td(4)=CM(2);			% velocities of P and Q		values(21)=-r2*td(2)*s2;		values(22)=r2*td(2)*c2;		values(23)=values(21)-r3*td(3)*s3;		values(24)=values(22)+r3*td(3)*c3;    end        %acceleration calculation	if flag>2		tdd(3)=tdd3;		BM=[r3*tdd(3)*s3+r3*td(3)*td(3)*c3+r2*td(2)*td(2)*c2-r4*td(4)*td(4)*c4;...   		r3*tdd(3)*c3-r3*td(3)*td(3)*s3-r2*td(2)*td(2)*s2+r4*td(4)*td(4)*s4];		CM=AM\BM;		tdd(2)=CM(1);		tdd(4)=CM(2);		% accelerations of P and Q		values(25)=-r2*tdd(2)*s2-r2*td(2)*td(2)*c2;		values(26)=r2*tdd(2)*c2-r2*td(2)*td(2)*s2;		values(27)=-r4*tdd(4)*s4-r4*td(4)*td(4)*c4;		values(28)=r4*tdd(4)*c4-r4*td(4)*td(4)*s4;    endend%store results in array valuesfor i = 1:4	values(i)=r(i);    values(i+4)=theta(i);    values(i+8)=td(i);	values(i+12)=tdd(i);end