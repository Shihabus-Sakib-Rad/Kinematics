function rbg_el_trammel_ana(Action,fx,fy,ax,ay,bx,by,theta)% the contents of the userdata of Analysis Window % handles(1) = handle of fig number% handles(2) = handle of fig1 popupmenu% handles(3) = handle of fig2 popupmenu% handles(4) = handle of fig3 popupmenu% handles(5) = handle of fig4 popupmenu% handles(6) = handle of axe1% handles(7) = handle of axe2% handles(8) = handle of axe3% handles(9) = handle of axe4% handles(10) = flag for deciding to start or stop animation% handles(11) = handle of bead(1)% handles(12) = handle of bead(2)% handles(13) = handle of bead(3)% handles(14) = handle of bead(4)% handles(15) = Previous Start Index% handles(16) = timesink% handles(17) = handle of reference axe for axe1% handles(18) = handle of reference axe for axe2% handles(19) = handle of reference axe for axe3% handles(20) = handle of reference axe for axe4% handles(21) = handle of submenu 'Load'% handles(22) = handle of submenu 'Save'% handles(23) = handle of return button;% handles(24) = handle of speed plus button;% each mechanism axes has the its own userdata storing its % unique graphic handle [joint1 joint2 crank coupler rocker];      global strFigType global nAnimationFlagglobal g_AnaResglobal nChangeSpeed% Define the axes for the first graph (input/output angle graph)if nargin==0 && isempty(findobj('Tag','RBG Elliptic Trammel Analysis Window')),  % rbg_el_trammel_ana is being initialized   Action='initialize';elseif nargin== 0 && ~isempty(findobj('Tag','RBG Elliptic Trammel Analysis Window'))      % rbg_el_trammel_ana is already open   Action='None';elseif nargin== 1 && ~isempty(findobj('Tag','RBG Elliptic Trammel Analysis Window')) && strcmp( Action, 'initialize'), % rbg_el_trammel_ana is already open	% Recalculate the value, and then redraw	Action='None';endswitch Actioncase 'initialize'   if  isempty(findobj('Tag','RBG Elliptic Trammel Analysis Window'))         LocalOpenFig;      nAnimationFlag = 0;   else  		rbg_el_trammel_ana('None');   end     if nargin < 6       fx = [ 1.5 0.8 ];      fy = [ 2.4 2.2 ];      ax = [ 0 3 2 ];      ay = [ 0 0 2 ];      theta = [ 45 135 0 ];   end      if exist('nAnimationFlag')       if nAnimationFlag == 1      	rbg_el_trammel_ana('Stop');         return;      end   end      a = findobj('Tag','RBG Elliptic Trammel Analysis Window');      handles = get(a,'userdata');   set(a,'userdata',handles);   g_AnaRes = CalcResult( fx,fy,ax,ay,bx,by,theta );   rbg_el_trammel_ana('ShowFigure');   rbg_el_trammel_ana('Start');    	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	%	Change Figure Call Back Function	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%case 'SetSpeed'   nChangeSpeed = fx(1);   case 'Animation'   a = findobj('Tag','RBG Elliptic Trammel Analysis Window');      handles = get(a,'userdata');      [ m, n ] = size( g_AnaRes);   itotal = n;   timesink = handles(16);   i = handles(15);      nFigNum  = 1;   nType(1) = 1;      h_plus = handles(24);   u = 0;   u = u+1; Bx = g_AnaRes(u,:);   u = u+1; By = g_AnaRes(u,:);   u = u+1; Cx = g_AnaRes(u,:);   u = u+1; Cy = g_AnaRes(u,:);   u = u+1; Dx = g_AnaRes(u,:);   u = u+1; Dy = g_AnaRes(u,:);   u = u+1; Ex = g_AnaRes(u,:);   u = u+1; Ey = g_AnaRes(u,:);      u = 12;    u = u+1; xblock= g_AnaRes(u:u+4,:);   u = u+5; yblock= g_AnaRes(u:u+4,:);   xblocka = xblock';   yblocka = yblock';   u = u+5; xblock= g_AnaRes(u:u+4,:);   u = u+5; yblock= g_AnaRes(u:u+4,:);   xblockb = xblock';   yblockb = yblock';         b = findobj('tag','rbg_el_trammel_anaaxes');   link = get(b,'userdata');   % set timer   dt = 5;   tic;      while nAnimationFlag                      cycle=fix((i-0.0000001)/(360/dt)); %determine the cycle as an integer      if i ==1         drawnow;      end      		SetMechanismPosition( link,i,Bx,By,Cx,Cy,Dx,Dy,Ex,Ey,xblocka,yblocka,xblockb,yblockb);                   drawnow;   %flush the draw buffer      i= i+1;      if i == itotal         i = 1;      end      if nChangeSpeed ~= 0         timesink = timesink * nChangeSpeed;         nChangeSpeed = 0;      end      while toc < timesink      end         tic;   end   nAnimationFlag = 0;   handles(15) = i;   handles(16) = timesink;   set(a,'Userdata',handles);   case 'ShowFigure'   a = findobj('Tag','RBG Elliptic Trammel Analysis Window');   handles = get( a,'userdata');   nFigNum = 1;%[ m, n ] = size( g_AnaRes);   npoints1 = g_AnaRes(33,17);   u = 8;   u = u+1; xsl1 = g_AnaRes(u,1:npoints1);   u = u+1; ysl1 = g_AnaRes(u,1:npoints1);   u = u+1; xsl2 = g_AnaRes(u,1:npoints1);   u = u+1; ysl2 = g_AnaRes(u,1:npoints1);      u = 33;   axislimit = g_AnaRes(u,1:4);   ax = g_AnaRes(u,5:7);   ay = g_AnaRes(u,8:10);   bx = g_AnaRes(u,11:13);   by = g_AnaRes(u,14:16);   handle = findobj('tag','rbg_el_trammel_anaaxes');   CreateMechanismHandles( handle,ax,ay,bx,by,axislimit,xsl1,ysl1,xsl2,ysl2);      refresh;      case 'None'   figure( findobj('Tag','rbg_el_trammel_ana'));% Bring the figure to front, if it already existscase 'Close'   rbg_el_trammel_ana('Stop');   a = findobj('Tag','RBG Elliptic Trammel Analysis Window');      close(a);case 'Start'   if exist('nAnimationFlag')      if nAnimationFlag == 1         return;      end   end      a = findobj('Tag','RBG Elliptic Trammel Analysis Window');      handles = get(a,'userdata');   set(handles(23),'Enable','off');      nAnimationFlag = 1;   nChangeSpeed = 0;   handles(10) = nAnimationFlag;   set(a,'userdata',handles);   rbg_el_trammel_ana('Animation');   case 'Stop'   if  isempty(findobj('Tag','RBG Elliptic Trammel Analysis Window'))     	return;      end   a = findobj('Tag','RBG Elliptic Trammel Analysis Window');      handles = get(a,'userdata');   nAnimationFlag = 0;   handles(10) = nAnimationFlag;   set(a,'userdata',handles);   set(handles(23),'Enable','on');   case 'Return'   rbg_el_trammel_ana('Stop');   a = findobj('Tag','RBG Elliptic Trammel Analysis Window');      handles = get(a,'userdata');   if ~isempty(findobj('Tag','rbg_el_trammel_dsgn'))        	b = findobj('Tag','rbg_el_trammel_dsgn');      figure(b);     	b = findobj('Tag','RBG Elliptic Trammel Analysis Window');        	close(b);   else      return;         end        end % switchfunction LocalOpenFig()%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	Main Figure%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ScreenSize = get(0,'ScreenSize');sx = 520;sy = 440;FigPos = [ ScreenSize(3)-sx-10 ScreenSize(4)-sy-95 sx sy ] ;a = figure('Units','Pixels', ...	'Color',[0.8 0.8 0.8], ...   'Name','RBG Elliptic Trammel Analysis Window', ...    'NumberTitle','off', ...	'Position',FigPos, ... 	'Tag','RBG Elliptic Trammel Analysis Window');	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % Draw the frame for Figure Selection%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%b = uicontrol('Parent',a, ...   'Units','normalized', ...   'BackgroundColor',[0.752941 0.752941 0.752941], ...	'Position',[0.00769 0.02727 0.2873 0.08409], ...   'Style','frame', ...   'Tag','Frame_angle');b = uicontrol('Parent',a, ...   'Units','normalized', ...   'ListboxTop',0, ...	'Position',[0.602 0.02727 0.3858 0.08409], ...   'Style','frame', ...   'Tag','Frame_pushbutton');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Axes%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%-------Reference axisb = axes('Parent',a, ...   'Box','on', ...   'Color',[1 1 1], ...   'Position',[0.00625 0.125 0.97917 0.865], ...   'XColor',[0 0 0], ...   'XGrid','off', ...   'XTick',[],...   'YColor',[0 0 0], ...   'YGrid','off', ...   'YTick',[], ...   'ZColor',[0 0 0], ...   'ZGrid','off', ...   'ZTick',[]);   b = axes('Parent',a, ...   'Box','off', ...   'DataAspectRatio',[1 1 1],...   'CameraUpVector',[0 1 0], ...   'CameraUpVectorMode','manual', ...   'Position',[0.00625 0.125 0.97917 0.865], ...   'Tag','rbg_el_trammel_anaaxes');axis off;   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Speed Control%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%b = uicontrol('Parent',a, ...	'Units','normalized', ...   'Position',[0.03 0.04 0.08 0.05], ...   'String','Speed ', ...	'Style','text', ... 	'Tag','StaticText2');	h_plus = uicontrol('Parent',a, ...	'Units','normalized', ...   'Callback','rbg_el_trammel_ana(''SetSpeed'',0.707);', ...   'Position',[0.1127 0.044 0.08 0.05], ... 	'String','+', ...	'Enable','on', ...	'Tag','Plus_button');b = uicontrol('Parent',a, ...	'Units','normalized', ...   'Callback','rbg_el_trammel_ana(''SetSpeed'',1.414);', ...   'Position',[0.2 0.044 0.08 0.05], ...   'String','-', ...	'Tag','Minus_button');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Start/Stop/Return%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%h_start = uicontrol('Parent',a, ...	'Units','normalized', ...	'CallBack','rbg_el_trammel_ana(''Start'')', ...   'Position',[0.612 0.044 0.12 0.05], ...  	'String','Start', ...	'Tag','start_button');h_stop = uicontrol('Parent',a, ...	'Units','normalized', ...	'CallBack','rbg_el_trammel_ana(''Stop'')', ...   'Position',[0.736 0.044 0.12 0.05], ...	'String','Stop', ...	'Userdata',1,...	'Tag','stop_button');h_return = uicontrol('Parent',a, ...	'Units','normalized', ...	'CallBack','rbg_el_trammel_ana(''Return'')', ...   'Position',[0.859 0.044 0.12 0.05], ...	'String','Return', ...	'Tag','return_button');drawnow;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Assign Initial value%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%nAnimationFlag = 0;handles = zeros( 1, 24);handles(10) = nAnimationFlag;handles(15) = 1;% initial animation starting indexhandles(16) = 0.1;% initial timesink valuehandles(23) = h_return;handles(24) = h_plus;set( a, 'Userdata', handles);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	Calculate the result%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function [res] = CalcResult(fx,fy,ax,ay,bx,by,theta );fact=pi/180;drawfact=20;theta1 = theta(1);theta2 = theta(2);theta3 = theta(3);theta1r=theta1*fact;theta2r=theta2*fact;theta3r=theta3*fact;ax1 = ax(1);ax2 = ax(2);ax3 = ax(3);ay1 = ay(1);ay2 = ay(2);ay3 = ay(3);ax=[ax1 ax2 ax3];ay=[ay1 ay2 ay3];drawlim1=max([max(ax); max(ay); max(bx); max(by)]);drawlim2=min([max(ax); min(ay); min(bx); min(by)]);drawlim=drawfact*max([abs(drawlim1); abs(drawlim2)]);% Identify poles using pole.m function.p12=pole([ax(1);ay(1)],[ax(2);ay(2)],[bx(1);by(1)],[bx(2);by(2)]);	p13=pole([ax(1);ay(1)],[ax(3);ay(3)],[bx(1);by(1)],[bx(3);by(3)]);p23=pole([ax(2);ay(2)],[ax(3);ay(3)],[bx(2);by(2)],[bx(3);by(3)]);pflag12=p12(3);pflag13=p13(3);pflag23=p23(3);pflagtot=pflag12+pflag13+pflag23;% Identify the image pole p'23p23prime=ipole(p12,p13,p23);% Find the circle of sliders relative to the coupler if the poles are finite.if pflagtot==0; 	center=pole([p12(1);p12(2)],[p13(1);p13(2)],[p13(1);p13(2)],...      [p23prime(1);p23prime(2)]);  	x0=center(1);  	y0=center(2);  	dflag=center(3);  	rc=sqrt((p12(1)-x0)^2+(p12(2)-y0)^2);% Draw the circle relative to the frame when the poles are all finite.  	dalpha=2*pi/30;  	for j=1:1:31  		sx(j)=ax1;  		sy(j)=ay1;  		alpha=(j-1)*dalpha;  		if dflag==0  			sx(j)=x0+rc*cos(alpha);  			sy(j)=y0+rc*sin(alpha);  		end  	endend% Draw straight line relative to the frame a pole lies at infinityif pflagtot>0  	rc=10^10;  	dflag=1;  	stline=cosline(p12,p13,p23,p23prime);  	for j=1:1:31  		sx(j)=stline(j,1);  		sy(j)=stline(j,2);  	end  	cirangle=pi/2+atan2((sy(31)-sy(1)), (sx(31)-sx(1)));  	x0=sx(15)+rc*cos(cirangle);  	y0=sy(15)+rc*sin(cirangle);end% Draw straight line relative to the frame if pole lies at infinityif pflagtot>0  	stline=cosline(p12,p13,p23,p23prime);  	for j=1:1:31  		sx(j)=stline(j,1);  		sy(j)=stline(j,2);  	endend% If a pole is far from the positions, do not draw itp12x=p12(1);if abs(p12x) > drawlim; p12x=ax; endp12y=p12(2);if abs(p12y) > drawlim; p12y=ay; endp13x=p13(1);if abs(p13x) > drawlim; p13x=ax; endp13y=p13(2);if abs(p13y) > drawlim; p13y=ay; endp23x=p23(1);if abs(p23x) > drawlim; p23x=ax; endp23y=p23(2);if abs(p23y) > drawlim; p23y=ay; endscale=sqrt((max(ax)-min(ax))^2+(max(ay)-min(ay))^2);rpivot=0.02*scale;delta=2*rpivot;	%=============================================================% Part of program where joints are selected.%=============================================================% The point selected is in the frame coordinate system.  Transform% the point to the coupler coordinate system. % Rectify the point to the slider point circle.  First find the line from % the point chosen to the center of the circle.  Then find the point on the% circle that is on the line.  The center of the circle is at x0, y0, and % the radius of the circle is rc.  st1=sin(theta1r);ct1=cos(theta1r);flag=1;for n = 1:2	angle=atan2(fy(n)-y0, fx(n)-x0);	xn=x0+rc*cos(angle);	yn=y0+rc*sin(angle);   % The point selected is in the frame coordinate system.  Transform% the point to the coupler coordinate system. 				% Compute the three positions of the slider point and slider line coordinates	Xn1= (xn-ax1)*ct1+(yn-ay1)*st1;	Yn1= -(xn-ax1)*st1+(yn-ay1)*ct1;					% Determine coordinates of the slider point for three positions	Values=sliderpoint(ax1,ay1,theta1,ax2,ay2,theta2, ax3,ay3,...		 theta3,Xn1,Yn1);	for ii=1:1:3		asx(ii)=Values(2*ii-1);		asy(ii)=Values(2*ii);	end		% Determine the coordinates of the slider line	lineangle(n)=Values(7)*fact;	length=Values(8);	if length < 3*delta; length=3*delta; end	ndash=20;	csang(n)=cos(lineangle(n));	ssang(n)=sin(lineangle(n));	xe = asx(1)-0.5*length*csang;	ye = asy(1)-0.5*length*ssang;	lineangled(n)=Values(7);%	coord=frameline(2*length,xe,ye,ndash,lineangled(n),flag);	npoints=3*ndash;% draw the first slider block	xpin(n)=asx(1);	ypin(n)=asy(1);%	coords = rect(4*delta,2*delta,xpin(n),ypin(n),lineangled(n),0);end	% **********************************************************************% Elliptic Trammel linkage designed.  Proceed with analysis% **********************************************************************% Define angles and distances to the original coupler line.temp=atan2((ay(1)-ypin(1)), (ax(1)-xpin(1)));phi=atan2((ypin(2)-ypin(1)), (xpin(2)-xpin(1)));beta1=temp-phi;temp=atan2((by(1)-ypin(1)), (bx(1)-xpin(1)));beta2=temp-phi;rc2=sqrt((by(1)-ypin(1))^2+ (bx(1)-xpin(1))^2);rc1=sqrt((ay(1)-ypin(1))^2+ (ax(1)-xpin(1))^2);% Define link lengths and offset distance (r4)r3=sqrt((ypin(2)-ypin(1))^2+(xpin(2)-xpin(1))^2);% determine the parameters needed to analyse the % mechanism.  First locate the coordinates where the two slider % lines intersect.  Define each line parametrically in terms of % s1 and s2.A=[csang(1) -csang(2); ssang(1) -ssang(2)];B=[xpin(2)-xpin(1); ypin(2)-ypin(1)];s=A\B;xint=xpin(1)+s(1)*csang(1);yint=ypin(1)+s(1)*ssang(1);mode=1;% Determine the angle between the two lines.beta=lineangled(1)-lineangled(2);% Analyze the linkage for r1 between r1min and r1maxthetas=0;thetaf=360;flag=1;i=0;Qd3=0;Qdd3=0;dt=(thetaf-thetas)/300;for Q31 = thetas:dt:thetaf	points=prrpc(r3,lineangled(2),Q31,Qd3,Qdd3,beta,flag); 	i=i+1;	Bx(i)=points(25)+xint;	By(i)=points(26)+yint;	Cx(i)=points(27)+xint;	Cy(i)=points(28)+yint;% Locate original a and b on coupler.  The angle Q31 is from% slider 2 to slider 2.  We need the angle from slider 1 to slider 2 % so subtract 180 degrees from Q31 to get theta3.	theta3=(Q31-180)*pi/180;	Dx(i) = Cx(i)+rc1*cos(theta3+beta1);	Dy(i) = Cy(i)+rc1*sin(theta3+beta1);	Ex(i) = Cx(i)+rc2*cos(theta3+beta2);	Ey(i) = Cy(i)+rc2*sin(theta3+beta2);	% Locate the slider block coordinates	xpin=Cx(i);	ypin=Cy(i);	coords = rect(4*delta,2*delta,xpin,ypin,lineangled(1),0);	for j=1:1:5		xblocka(i,j)=coords(j,1);		yblocka(i,j)=coords(j,2);	end	xpin=Bx(i);	ypin=By(i);	coords = rect(4*delta,2*delta,xpin,ypin,lineangled(2),0);	for j=1:1:5		xblockb(i,j)=coords(j,1);		yblockb(i,j)=coords(j,2);	endenditotal=i;	% Find the max and min values for Cx and Bx for the sliderlines.[max2x, k2x]=max(Bx);[min2x, j2x]=min(Bx);[max1x, k1x]=max(Cx);[min1x, j1x]=min(Cx);lang1=atan2(Cy(k1x)-Cy(j1x), Cx(k1x)-Cx(j1x));lang2=atan2(By(k2x)-By(j2x), Bx(k2x)-Bx(j2x));cosang1=cos(lang1);cosang2=cos(lang2);sisang1=sin(lang1);sisang2=sin(lang2);langd1=lang1*180/pi;langd2=lang2*180/pi;	% Determine the extended coordinates of the slider lines at C and B.			slength1=sqrt((Cx(k1x)-Cx(j1x))^2+(Cy(k1x)-Cy(j1x))^2)+6*delta;slength2=sqrt((Bx(k2x)-Bx(j2x))^2+(By(k2x)-By(j2x))^2)+6*delta;ndash=30;xe1 = Cx(j1x)-3*delta*cosang1;ye1 = Cy(j1x)-3*delta*sisang1;xe2 = Bx(j2x)-3*delta*cosang2;ye2 = By(j2x)-3*delta*sisang2;flag=1;coord2=frameline(slength2,xe2,ye2,ndash,langd2,flag);					coord1=frameline(slength1,xe1,ye1,ndash,langd1,flag);					npoints1=3*ndash;					% Offset slider line by half the height of the slider blocks.					for i=1:1:npoints1	xsl2(i)=coord2(i,1)+delta*sisang2;	ysl2(i)=coord2(i,2)-delta*cosang2;	xsl1(i)=coord1(i,1)+delta*sisang1;	ysl1(i)=coord1(i,2)-delta*cosang1;end					% Calculate the axis rangewidth=0.8;height=0.8;% Define axestemp1= [Bx, Cx, Dx, Ex,ax,bx,ax1,ax2,ax3,xsl1,xsl2];xmins=min(temp1);xmaxs=max(temp1);temp2=[By, Cy, Dy, Ey,ay,by,ay1,ay2,ay3,ysl1,ysl2];ymins=min(temp2);ymaxs=max(temp2);rangex=xmaxs-xmins;rangey=ymaxs-ymins;% Define the plot limitsxmin=xmins-0.1*rangex;ymin=ymins-0.1*rangey;xmax=xmaxs+0.1*rangex;ymax=ymaxs+0.1*rangey;values=axisadjust(xmin, xmax, ymin, ymax, width, height);xmin=values(1);xmax=values(2);ymin=values(3);ymax=values(4);% Store position velocity and acceleration information in matrices.res = zeros( 29, itotal);i = 0;% Bx,By,Cx,Cy,Dx,Dy and Ex,Ey are the data used to draw% linkage in mode = -1i = i+1; res( i,: ) = Bx;i = i+1; res( i,: ) = By;i = i+1; res( i,: ) = Cx;i = i+1; res( i,: ) = Cy;i = i+1; res( i,: ) = Dx;i = i+1; res( i,: ) = Dy;i = i+1; res( i,: ) = Ex;i = i+1; res( i,: ) = Ey;% xsl1, ysl1 and xblocka, yblocka have their matrix sizes different from% most of the other data. Therefore, they are taken care of separately.% We just store xsl1 and ysl1 in part of the 'res' matrix. To retrieve% only that part of matrix from the g_Anares variables later when xsl1 and% ysl2 are needed, the variable npoints1 is stored in this global variable% at res(38,17)i = i+1; res( i,1:npoints1 ) = xsl1;i = i+1; res( i,1:npoints1 ) = ysl1;i = i+1; res( i,1:npoints1 ) = xsl2;i = i+1; res( i,1:npoints1 ) = ysl2;% xblocka and yblocka are matries with size (itotal,5)% Because we need to store them into the 'res' variable, xblock and yblock are% created to transpose these two matries. Then they use five columns of 'res' % to store them xblock = xblocka';yblock = yblocka';i = i+1; res( i:i+4,: ) = xblock;i = i+5; res( i:i+4,: ) = yblock;xblock = xblockb';yblock = yblockb';i = i+5; res( i:i+4,: ) = xblock;i = i+5; res( i:i+4,: ) = yblock;i = i+5;res( i,1:4 ) = [xmin xmax ymin ymax];res( i,5:7 ) = ax;res( i,8:10 ) = ay;res( i,11:13 ) = bx;res( i,14:16 ) = by;res( i,17 ) = npoints1;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Fig Setting for Special Case%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function [] = CreateMechanismHandles( handle,ax,ay,bx,by,axislimit,xsl1,ysl1,xsl2,ysl2) axes(handle);%setup the aspect ratio of the mechanism to 1 set(handle, 'DataAspectRatio',[1 1 1],'Color','none','box','off');axis off;xmin = axislimit(1);xmax = axislimit(2);ymin = axislimit(3);ymax = axislimit(4);axis([xmin xmax ymin ymax]);position1=line('xdata', [], 'ydata' ,[], 'linewidth',2,'color', 'r');position2=line('xdata', [], 'ydata' ,[], 'linewidth',2,'color', 'b');position3=line('xdata', [], 'ydata' ,[], 'linewidth',2,'color', 'g');sliderline1=line('xdata', [], 'ydata' ,[], 'linewidth',1,'color', 'r');sliderline2=line('xdata', [], 'ydata' ,[], 'linewidth',1,'color', 'r');a1=line('xdata', [], 'ydata', [], 'marker', '+','markersize',10, 'color', 'r');a2=line('xdata', [], 'ydata', [], 'marker', '+','markersize',10,'color', 'b');a3=line('xdata', [], 'ydata', [], 'marker', '+','markersize',10,'color', 'g');joint1=line('xdata', [], 'ydata',[], 'marker', 'o', 'markersize', 8,'color', 'k');joint2=line('xdata', [], 'ydata',[], 'marker', 'o', 'markersize', 8,'color', 'k');coupler1=line('xdata', [], 'ydata', [],'linewidth',2,'color', 'k');coupler2=line('xdata', [], 'ydata' ,[], 'linewidth' ,2,'color', 'k');coupler3=line('xdata', [], 'ydata' ,[], 'linewidth' ,2,'color', 'b');block1=line('xdata', [], 'ydata',[],'linewidth' ,1, 'color', 'k');block2=line('xdata', [], 'ydata',[],'linewidth' ,1, 'color', 'k');% Plot fixed quantities		 set(position1, 'xdata', [ax(1) bx(1)], 'ydata', [ay(1) by(1)]);set(position2, 'xdata', [ax(2) bx(2)], 'ydata', [ay(2) by(2)]);set(position3, 'xdata', [ax(3) bx(3)], 'ydata', [ay(3) by(3)]);set(sliderline1, 'xdata', xsl1, 'ydata', ysl1);set(sliderline2, 'xdata', xsl2, 'ydata', ysl2);set(a1, 'xdata',ax(1), 'ydata', ay(1));set(a2, 'xdata',ax(2), 'ydata', ay(2));set(a3, 'xdata',ax(3), 'ydata', ay(3));text(ax(1)+0.1,ay(1),'A1');text(ax(2)+0.1,ay(2),'A2');text(ax(3)+0.1,ay(3),'A3');drawnow;hdls=[ coupler1 coupler2 coupler3 block1 block2];set(handle,'userdata',hdls);zoom on     % mouse left click / zoom box using mouse drag%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Set the mechanism position%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function [] = SetMechanismPosition( links,i,Bx,By,Cx,Cy,Dx,Dy,Ex,Ey,xblocka,yblocka,xblockb,yblockb)coupler1 = links(1);coupler2 = links(2);coupler3 = links(3);block1 = links(4);block2 = links(5);set(coupler1,'xdata', [Cx(i), Bx(i)],'ydata', [Cy(i), By(i)]);set(coupler2,'xdata', [Bx(i), Dx(i)],'ydata', [By(i), Dy(i)]);set(coupler3,'xdata', [Dx(i), Ex(i)],'ydata', [Dy(i), Ey(i)]);		for j=1:1:5	xblock(j)=xblocka(i,j);	yblock(j)=yblocka(i,j);endset(block1,'xdata', xblock, 'ydata',yblock);for j=1:1:5	xblock(j)=xblockb(i,j);	yblock(j)=yblockb(i,j);endset(block2,'xdata', xblock, 'ydata',yblock);